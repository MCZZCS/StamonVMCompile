<!--
 * @Name: 虚拟机IR设计.md
 * @Copyright: Apache 2.0
 * @Author: CLimber-Rong
 * @Date: 08/12/23 19:36
 * @Description: STVM IR设计文档，文档版本v1.12
-->
# STVM IR设计

> 本文档仅设计IR的命令和格式，不对其具体的操作码、操作数等进行设计

### 标识符

STVM IR的命名规则可参考C语言的命名规则。

但是注意：**STVM的标识符可以包含小数点**，通常情况下，我们会在内部变量的开头加上一个小数点以作区分。

在当前作用域声明标识符的具体格式为：

```
def 标识符1, 标识符2, ..., 标识符n
```

STVM IR在编译成字节码时，会把标识符转换为数字编号，即每个标识符对应着唯一的数字编号。

### 段标记、函数和类


* 你可以在函数当中的任意地方进行声明一个段标记，这样你就可以跳转到段标记所在的位置。

具体格式为：

```
section 段标记名 
```

段标记并不能作为变量使用，而只能用于跳转。


* 在STVM当中，函数的定义是一个对象。函数的声明位于类的外部。

具体格式为：

```
function 函数名: 参数1, 参数2, ..., 参数n
    ...
end
```

通常的，一个普通的函数对象是没有容器的（即容器为空）。想要让一个函数对象成为一个类对象的成员（也就是成为方法），就需要绑定这个函数对象的容器。

当调用一个函数对象时，如果这个函数对象有容器，那么函数的第一个参数就是容器。换句话说，一个方法的定义应该是这样的：

```
function 方法名: this, 参数1, 参数2, ..., 参数n
    ...
end
```

* 在STVM当中，类的定义是一个对象。类的声明应该包含类的名字以及这个类所包含的成员。
<br>
类的内部应该是__init__函数（即构造函数），__init__函数执行时应该给各成员赋值。

具体格式为：

```
class 类名: 成员1, 成员2, ..., 成员n
    __init__: 参数1, 参数2, ..., 参数n
        ...
    end
end
```

### 命令

> 从现在开始，将“栈顶下的第x个元素”简记为S(x)，其中S(0)代表栈顶。如果下述出现“弹出x个元素”，是指将操作数栈弹出x个元素。

##### 内存控制指令

* mov：赋值，无参数，将S(1)赋值为S(0)，其中S(1)必须是变量。该指令执行后弹出两个元素。
* member：获取成员变量，无参数。上述提到，STVM IR编译成的字节码会把标识符数字编号化。所以这个指令会提取S(1)中名为S(0)的成员（其中S(1)是对象，S(0)是整数，即数字编号化后的成员标识符），接着弹出两个元素，压入提取出的成员。
* index：获取数列的元素，无参数。这个指令会提取``S(1)[S(0)]``（其中S(1)是数列，S(0)是整数），并弹出两个元素，接着压入提取出的元素。

##### 运算指令

> 从现在开始，我将定义一大堆的二元运算符，它们的都是把S(1)和S(0)进行运算，并弹出两个元素，把运算后的结果入栈。为了简便，我将不再在下述定义当中陈述上述语言。

<br>

* add, sub, mul，div：加，减，乘，除
* mod：取余
* shl, shr：左移，右移
* less, lessequ, big, bigequ：小于，小等于，大于，大等于
* equ, notequ：判等，判不等
* bitand：按位与
* bitxor：按位异或
* bitor：按位或
* and：逻辑与
* or：逻辑或

<br>

> 从现在开始，我将定义一大堆的一元运算符，它们的都是把S(0)进行运算，并弹出一个元素，把运算后的结果入栈。为了简便，我将不再在下述定义当中陈述上述语言。

* inc：自增1
* dec：自减1
* not：逻辑非
* bitnot：按位非
* neg：取负数
* pos：取正数

##### 对象创建指令

* new：新建对象，无参数，将S(0)作为需要新建的类的定义，弹出一个元素，并压入新建的对象

**值得注意的是：这个指令在新建对象的过程中并没有调用构造函数，所以用户在新建对象后还需自行调用构造函数（调用构造函数的办法和调用普通函数的一致）**

* arr：新建指定长度的数列，无参数，以S(0)作为长度（其中S(0)为自然数），新建一个数列（新建的数列里的元素全为null），弹出一个元素，并把该数列入栈
* list：新建指定内容的数列，格式为``list L``，其中L为自然数。该指令将新建一个长度为L，内容为``{S(L-1), S(L-2), .., S(0)}``的数列，接着弹出L个元素，并把该数列入栈
* fun：格式为``fun 函数名``，新建一个指定的函数对象，压入新建后的对象
* bind：无参数，这个指令在mov的基础上多出一条规则：如果要赋的值是函数对象，那么就把这个函数对象的容器设为``this``变量。这个指令通常用于类对象的初始化赋值，可以绑定类函数成员的容器。


##### 操作栈控制指令

* push：入栈，格式为``push 变量``
* pop：出栈，格式为``pop``或``pop 变量``前者pop后不做任何处理，后者pop的同时把pop出的值存到变量当中。

##### 流程控制指令

* if：指令格式为``if 段标记名``，调用该指令时，如果S(0)不为0或null，那么跳转到该段标记所在位置，否则继续往下执行。在该指令执行后，弹出一个元素
* jmp：指令格式为``jmp 段标记名``，无条件跳转到该段标记名所在处。

##### 作用域控制指令

* pushscope：无参数，该指令可以新建一个作用域
* popscope：无参数，该指令可以退出一个作用域

##### 函数调用和返回指令

* call：调用函数，无参数，这个指令的具体执行流程是：

设被调用的函数参数个数为n，以S(n+1)作为被调用的函数，把S(n), S(n-1), ..., S(0)依次作为函数的参数。接着弹出n+1个元素，新建一个作用域，最后调用函数。

**特别注意：如果被调用的函数对象是方法，那么该函数对象的容器将作为第一个参数。**

* ret：无参数，返回指令，该指令执行后会退出一个作用域。

##### SFN指令

SFN，全程Stamon For Native（~~真的不是So Fck NVIDIA~~）。是StamonVM的一个调用外部功能的机制。你可以用它与解释器交互。

例如文件写入、屏幕输出，都应该利用SFN完成。

SFN机制规定了一系列外部功能，每个功能都有它唯一对应的端口号。用户可以通过端口号调用功能。

用户在功能时，还需要给这个功能传递相应的参数。

* sfn：无参数，会以S(1)作为端口号，S(0)作为参数调用SFN，执行后弹出两个元素。其中，S(1)必须是整数。

### 程序入口

为了方便，我们将程序入口统一为名为main类的构造函数。