<!--
 * @Name: 虚拟机STVC设计.md
 * @Copyright: Apache2.0
 * @Author: CLimber-Rong
 * @Date: 10/12/23 14:07
 * @Description: STVC-IR设计文档，文档版本v1.5
-->

> 下述标准被称为STVC-IR标准

# STVC设计

STVC（StamonVm Code）是STVM字节码的简称。

STVC由STVM IR编译而来。对于STVM IR的介绍参见``虚拟机IR设计.md``

### 文件后缀

STVC的文件后缀是``.stvc``。

当然，这只是一种建议。STVM并没有对文件后缀有强制性要求。

### 文件头

一个字节码文件的开头应该按顺序包含以下内容

* 魔数：为了将STVC文件和其他文件区分，规定STVC的开头必须包含一个两字节的魔数：``0xABDB``。
* 版本：代表了编译这个STVC的Stamon2编译器版本，Stamon2版本的格式为``X.Y.Z``。版本在STVC当中占两个字节，第一个字节为X，第二个字节的前四位代表Y，第二个字节的后四位代表Z。（综上可知X的范围是0&#126;255，Y的范围是0&#126;15，Z的范围是0&#126;15）
* 常量表：**在STVC中，所有的常量出现且仅出现在常量表当中**

将所有常量放入常量表，这样所有指令的参数都为常量表的索引。虚拟机在执行指令时只需要根据指令的索引去常量表寻找相应的值即可。

常量表由一个四字节的整数N（代表常量表的项数）和N项常量组成。

常量表中的常量有以下几种

1. 整数常量：由一个四字节的``ID``（该常量在常量表中的索引），一个数值为``2``的字节（用来表示该常量为整数常量），以及四字节的整数数值（即该常量的值）
2. 单精度浮点数常量：由一个四字节的``ID``（该常量在常量表中的索引），一个数值为``3``的字节（用来表示该常量为整数常量），以及四字节的整数数值（即该常量的值）
3. 双精度浮点数常量：由一个四字节的``ID``（该常量在常量表中的索引），一个数值为``4``的字节（用来表示该常量为整数常量），以及八字节的整数数值（即该常量的值）
4. 字符串常量：由一个四字节的``ID``（该常量在常量表中的索引），一个数值为``5``的字节（用来表示该常量为整数常量），一个四字节的``L``（代表该字符串所占的字节数），以及大小为L的字符串（即该常量的值）
5. 标识符常量：由一个四字节的``ID``（该常量在常量表中的索引），一个数值为``10``的字节（用来表示该常量为标识符常量），以及四字节的整数数值（即该标识符的编号）

**在STVM当中，所有标识符都被数字编号化，所以我们可以直接用一个整数数值来代表它**

**值得注意的是，字符串常量的值（即字符串）的末尾应该带有'\0'**

### 指令

> 在``虚拟机IR设计.md``中就以提到：字节码和虚拟机内部都把标识符数字编号化了，所以在字节码当中，应该用一个数字代表标识符；又因为数字全部位于常量表当中，所以应该用一个常量表索引来代表标识符（并且该索引对应的常量应该是数字）

##### 程序入口声明

在文件头后，应该有一个常量表索引，该索引代表的是一个标识符，该标识符即为程序入口。具体的程序入口要求和执行程序入口的方法参见``虚拟机IR设计.md``

##### 方法和类的声明

在程序入口声明后，紧跟着方法和类的声明

方法和类的声明类似，都是以下结构：

* flag：一字节
* argc：四字节
* argv：共argc*4字节
* code：若干字节
* end：一字节

当声明方法时：flag=1，argc代表函数参数个数，argv为argc个常量索引（即由argc个标识符组成的函数参数列表），code为函数体。

当声明类时：flag=2，argc代表类成员个数，argv为argc个常量索引（即由argc个标识符组成的类成员列表），code为构造函数体。

end标志位意味着声明结束，**无论声明的是方法抑或是类，end恒为0**

##### 变量的声明

变量的声明位于方法或类构造函数当中。

变量声明的结构为：

* flag：一字节，该值恒为0x29，用来辨别当前指令用来声明变量
* len：四字节，该值代表声明变量的个数
* var：``len*4``字节，该值代表len个常量索引（即需要声明的len个变量）

##### 指令

指令位于方法或类构造函数当中。

接下来将介绍STVC的指令和其对应的二进制码。指令的功能、参数等参见``虚拟机IR设计.md``。**需要注意：下述所有指令的参数，都为常量索引。**

|二进制码（十六进制）|指令名|
|-|-|
|03|mov|
|04|member|
|05|index|
|06|add|
|07|sub|
|08|mul|
|09|div|
|0a|mod|
|0b|shl|
|0c|shr|
|0d|less|
|0e|lessequ|
|0f|big|
|10|bigequ|
|11|equ|
|12|notequ|
|13|bitand|
|14|bitxor|
|15|bitor|
|16|and|
|17|or|
|18|inc|
|19|dec|
|1a|not|
|1b|bitnot|
|1c|neg|
|1d|pos|
|1e|new|
|1f|push|
|20|pop|
|21|if|
|22|jmp|
|23|pushscope|
|24|popscope|
|25|call|
|26|ret|
|27|sfn|
|27|arr|
|28|list|
|2a|fun|
|2b|bind|

其中，``if``和``jmp``指令在IR层面和字节码层面不太一样：

由于STVC没有段标记这个概念，所以跳转的参数不再是段标记，而是相对偏移量。相对偏移量的计算方式为：

设需要跳转的段标记与当前位置隔着``N``条指令，当向上跳转时，指令参数为``N-1``；当向下跳转时，指令参数为``N+1``。

值得注意：**无论是``N-1``抑或是``N+1``，都被放在常量表当中，所以该参数也应是常量**